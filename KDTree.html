

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Building a kd-tree &mdash; CookBook 0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="CookBook 0.1 documentation" href="index.html" />
    <link rel="next" title="&lt;no title&gt;" href="KalmanFiltering.html" />
    <link rel="prev" title="Find the points at which two given functions intersect" href="Intersection.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="KalmanFiltering.html" title="&lt;no title&gt;"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Intersection.html" title="Find the points at which two given functions intersect"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">CookBook 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <p><strong>&#8216;Note: there is an implementation of a kdtree in scipy:
http://docs.scipy.org/scipy/docs/scipy.spatial.kdtree.KDTree/ It is
recommended to use that instead of the below.</strong>&#8216;</p>
<p>This is an example of how to construct and search a
<a class="reference external" href="http://en.wikipedia.org/wiki/Kd-tree">kd-tree</a> in
<a class="reference external" href="http://www.python.org">Python</a>with NumPy. kd-trees are e.g. used
to search for neighbouring data points in multidimensional space.
Searching the kd-tree for the nearest neighbour of all n points has O(n
log n) complexity with respect to sample size.</p>
<div class="section" id="building-a-kd-tree">
<h1>Building a kd-tree<a class="headerlink" href="#building-a-kd-tree" title="Permalink to this headline">Â¶</a></h1>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!python numbers=disable</span>

<span class="c"># Copyleft 2008 Sturla Molden</span>
<span class="c"># University of Oslo</span>

<span class="c">#import psyco</span>
<span class="c">#psyco.full()</span>

<span class="kn">import</span> <span class="nn">numpy</span>

<span class="k">def</span> <span class="nf">kdtree</span><span class="p">(</span> <span class="n">data</span><span class="p">,</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">10</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    build a kd-tree for O(n log n) nearest neighbour search</span>

<span class="sd">    input:</span>
<span class="sd">        data:       2D ndarray, shape =(ndim,ndata), preferentially C order</span>
<span class="sd">        leafsize:   max. number of data points to leave in a leaf</span>

<span class="sd">    output:</span>
<span class="sd">        kd-tree:    list of tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ndata</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c"># find bounding hyper-rectangle</span>
    <span class="n">hrect</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">hrect</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">hrect</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c"># create root of kd-tree</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;mergesort&#39;</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">splitval</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">ndata</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">left_hrect</span> <span class="o">=</span> <span class="n">hrect</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">right_hrect</span> <span class="o">=</span> <span class="n">hrect</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">left_hrect</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">splitval</span>
    <span class="n">right_hrect</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">splitval</span>

    <span class="n">tree</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">left_hrect</span><span class="p">,</span> <span class="n">right_hrect</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">data</span><span class="p">[:,:</span><span class="n">ndata</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="n">idx</span><span class="p">[:</span><span class="n">ndata</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span>
             <span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">ndata</span><span class="o">/</span><span class="mi">2</span><span class="p">:],</span> <span class="n">idx</span><span class="p">[</span><span class="n">ndata</span><span class="o">/</span><span class="mi">2</span><span class="p">:],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">False</span><span class="p">)]</span>

    <span class="c"># recursively split data in halves using hyper-rectangles:</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>

        <span class="c"># pop data off stack</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">didx</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">leftbranch</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">ndata</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nodeptr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>

        <span class="c"># update parent node</span>

        <span class="n">_didx</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">_left_hrect</span><span class="p">,</span> <span class="n">_right_hrect</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span>

        <span class="n">tree</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">_didx</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">_left_hrect</span><span class="p">,</span> <span class="n">_right_hrect</span><span class="p">,</span> <span class="n">nodeptr</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
 <span class="k">if</span> <span class="n">leftbranch</span> \
            <span class="k">else</span> <span class="p">(</span><span class="n">_didx</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">_left_hrect</span><span class="p">,</span> <span class="n">_right_hrect</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">nodeptr</span><span class="p">)</span>

        <span class="c"># insert node in kd-tree</span>

        <span class="c"># leaf node?</span>
        <span class="k">if</span> <span class="n">ndata</span> <span class="o">&lt;=</span> <span class="n">leafsize</span><span class="p">:</span>
            <span class="n">_didx</span> <span class="o">=</span> <span class="n">didx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">leaf</span> <span class="o">=</span> <span class="p">(</span><span class="n">_didx</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span>

        <span class="c"># not a leaf, split the data in two</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">splitdim</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">%</span> <span class="n">ndim</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">splitdim</span><span class="p">,:],</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;mergesort&#39;</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[:,:]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">didx</span> <span class="o">=</span> <span class="n">didx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">nodeptr</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">data</span><span class="p">[:,:</span><span class="n">ndata</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="n">didx</span><span class="p">[:</span><span class="n">ndata</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nodeptr</span><span class="p">,</span> <span class="n">Tr</span>
<span class="n">ue</span><span class="p">))</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">data</span><span class="p">[:,</span><span class="n">ndata</span><span class="o">/</span><span class="mi">2</span><span class="p">:],</span> <span class="n">didx</span><span class="p">[</span><span class="n">ndata</span><span class="o">/</span><span class="mi">2</span><span class="p">:],</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nodeptr</span><span class="p">,</span> <span class="n">Fa</span>
<span class="n">lse</span><span class="p">))</span>
            <span class="n">splitval</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">splitdim</span><span class="p">,</span><span class="n">ndata</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">leftbranch</span><span class="p">:</span>
                <span class="n">left_hrect</span> <span class="o">=</span> <span class="n">_left_hrect</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">right_hrect</span> <span class="o">=</span> <span class="n">_left_hrect</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left_hrect</span> <span class="o">=</span> <span class="n">_right_hrect</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">right_hrect</span> <span class="o">=</span> <span class="n">_right_hrect</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">left_hrect</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">splitdim</span><span class="p">]</span> <span class="o">=</span> <span class="n">splitval</span>
            <span class="n">right_hrect</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">splitdim</span><span class="p">]</span> <span class="o">=</span> <span class="n">splitval</span>
            <span class="c"># append node to tree</span>
            <span class="n">tree</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">left_hrect</span><span class="p">,</span> <span class="n">right_hrect</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">tree</span>
</pre></div>
</div>
</div>
<div class="section" id="searching-a-kd-tree">
<h1>Searching a kd-tree<a class="headerlink" href="#searching-a-kd-tree" title="Permalink to this headline">Â¶</a></h1>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!python numbers=disable</span>


<span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="n">hrect</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">centroid</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    checks if the hyperrectangle hrect intersects with the</span>
<span class="sd">    hypersphere defined by centroid and r2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">maxval</span> <span class="o">=</span> <span class="n">hrect</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span>
    <span class="n">minval</span> <span class="o">=</span> <span class="n">hrect</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">centroid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">minval</span>
    <span class="n">p</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">minval</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="n">maxval</span>
    <span class="n">p</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">maxval</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">((</span><span class="n">p</span><span class="o">-</span><span class="n">centroid</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">r2</span>


<span class="k">def</span> <span class="nf">quadratic_knn_search</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">lidx</span><span class="p">,</span> <span class="n">ldata</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; find K nearest neighbours of data among ldata &quot;&quot;&quot;</span>
    <span class="n">ndata</span> <span class="o">=</span> <span class="n">ldata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">ldata</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">K</span> <span class="k">if</span> <span class="n">K</span> <span class="o">&lt;</span> <span class="n">ndata</span> <span class="k">else</span> <span class="n">ndata</span>
    <span class="n">retval</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sqd</span> <span class="o">=</span> <span class="p">((</span><span class="n">ldata</span> <span class="o">-</span> <span class="n">data</span><span class="p">[:,:</span><span class="n">ndata</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c"># data.reshape((param,1)).re</span>
<span class="n">peat</span><span class="p">(</span><span class="n">ndata</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">sqd</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s">&#39;mergesort&#39;</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:</span><span class="n">K</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sqd</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">lidx</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">search_kdtree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">datapoint</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; find the k nearest neighbours of datapoint in a kdtree &quot;&quot;&quot;</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">knn</span> <span class="o">=</span> <span class="p">[(</span><span class="n">numpy</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span><span class="o">*</span><span class="n">K</span>
    <span class="n">_datapt</span> <span class="o">=</span> <span class="n">datapoint</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>

        <span class="n">leaf_idx</span><span class="p">,</span> <span class="n">leaf_data</span><span class="p">,</span> <span class="n">left_hrect</span><span class="p">,</span> \
                  <span class="n">right_hrect</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="c"># leaf</span>
        <span class="k">if</span> <span class="n">leaf_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">_knn</span> <span class="o">=</span> <span class="n">quadratic_knn_search</span><span class="p">(</span><span class="n">datapoint</span><span class="p">,</span> <span class="n">leaf_idx</span><span class="p">,</span> <span class="n">leaf_data</span><span class="p">,</span> <span class="n">K</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_knn</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">knn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">knn</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">knn</span> <span class="o">+</span> <span class="n">_knn</span><span class="p">)[:</span><span class="n">K</span><span class="p">]</span>

        <span class="c"># not a leaf</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c"># check left branch</span>
            <span class="k">if</span> <span class="n">intersect</span><span class="p">(</span><span class="n">left_hrect</span><span class="p">,</span> <span class="n">knn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">_datapt</span><span class="p">):</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">left</span><span class="p">])</span>

            <span class="c"># chech right branch</span>
            <span class="k">if</span> <span class="n">intersect</span><span class="p">(</span><span class="n">right_hrect</span><span class="p">,</span> <span class="n">knn</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">_datapt</span><span class="p">):</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">right</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">knn</span>


<span class="k">def</span> <span class="nf">knn_search</span><span class="p">(</span> <span class="n">data</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">2048</span> <span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; find the K nearest neighbours for data points in data,</span>
<span class="sd">        using an O(n log n) kd-tree &quot;&quot;&quot;</span>

    <span class="n">ndata</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c"># build kdtree</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">kdtree</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">leafsize</span><span class="o">=</span><span class="n">leafsize</span><span class="p">)</span>

    <span class="c"># search kdtree</span>
    <span class="n">knn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndata</span><span class="p">):</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">param</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">leafsize</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">_knn</span> <span class="o">=</span> <span class="n">search_kdtree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">knn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_knn</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="k">return</span> <span class="n">knn</span>


<span class="k">def</span> <span class="nf">radius_search</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">datapoint</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; find all points within radius of datapoint &quot;&quot;&quot;</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">inside</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>

        <span class="n">leaf_idx</span><span class="p">,</span> <span class="n">leaf_data</span><span class="p">,</span> <span class="n">left_hrect</span><span class="p">,</span> \
                  <span class="n">right_hrect</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="c"># leaf</span>
        <span class="k">if</span> <span class="n">leaf_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">param</span><span class="o">=</span><span class="n">leaf_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="n">leaf_data</span> <span class="o">-</span> <span class="n">datapoint</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">param</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span><span class="o">**</span><span class="mi">2</span>
<span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">near</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">distance</span><span class="o">&lt;=</span><span class="n">radius</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">near</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">leaf_idx</span><span class="p">[</span><span class="n">near</span><span class="p">]</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">near</span><span class="p">]</span>
                <span class="n">inside</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">intersect</span><span class="p">(</span><span class="n">left_hrect</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">datapoint</span><span class="p">):</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">left</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">intersect</span><span class="p">(</span><span class="n">right_hrect</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">datapoint</span><span class="p">):</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">right</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">inside</span>
</pre></div>
</div>
</div>
<div class="section" id="quadratic-search-for-small-data-sets">
<h1>Quadratic search for small data sets<a class="headerlink" href="#quadratic-search-for-small-data-sets" title="Permalink to this headline">Â¶</a></h1>
<p>In contrast to the kd-tree, straight forward exhaustive search has
quadratic complexity with respect to sample size. It can be faster than
using a kd-tree when the sample size is very small. On my computer that
is approximately 500 samples or less.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!python numbers=disable</span>

<span class="k">def</span> <span class="nf">knn_search</span><span class="p">(</span> <span class="n">data</span><span class="p">,</span> <span class="n">K</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; find the K nearest neighbours for data points in data,</span>
<span class="sd">        using O(n**2) search &quot;&quot;&quot;</span>
    <span class="n">ndata</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">knn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndata</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndata</span><span class="p">):</span>
        <span class="n">_knn</span> <span class="o">=</span> <span class="n">quadratic_knn_search</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="n">idx</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c"># see above</span>
        <span class="n">knn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">_knn</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">knn</span>
</pre></div>
</div>
</div>
<div class="section" id="parallel-search-for-large-data-sets">
<h1>Parallel search for large data sets<a class="headerlink" href="#parallel-search-for-large-data-sets" title="Permalink to this headline">Â¶</a></h1>
<p>While creating a kd-tree is very fast, searching it can be time
consuming. Due to Python&#8217;s dreaded &#8220;Global Interpreter Lock&#8221; (GIL),
threads cannot be used to conduct multiple searches in parallel. That
is, Python threads can be used for asynchrony but not concurrency.
However, we can use multiple processes (multiple interpreters). The
<a class="reference external" href="http://pyprocessing.berlios.de/">pyprocessing</a> package makes this
easy. It has an API similar to Python&#8217;s threading and Queue standard
modules, but work with processes instead of threads. Beginning with
Python 2.6, pyprocessing is already included in Python&#8217;s standard
library as the &#8220;multiprocessing&#8221; module. There is a small overhead of
using multiple processes, including process creation, process startup,
IPC, and process termination. However, because processes run in separate
address spaces, no memory contention is incurred. In the following
example, the overhead of using multiple processes is very small compared
to the computation, giving a speed-up close to the number of CPUs on the
computer.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!python numbers=disable</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="kn">as</span> <span class="nn">processing</span>
<span class="k">except</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">processing</span>

<span class="kn">import</span> <span class="nn">ctypes</span><span class="o">,</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">__num_processors</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;nt&#39;</span><span class="p">:</span> <span class="c"># Windows</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">&#39;NUMBER_OF_PROCESSORS&#39;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span> <span class="c"># glibc (Linux, *BSD, Apple)</span>
        <span class="n">get_nprocs</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">cdll</span><span class="o">.</span><span class="n">libc</span><span class="o">.</span><span class="n">get_nprocs</span>
        <span class="n">get_nprocs</span><span class="o">.</span><span class="n">restype</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span>
        <span class="n">get_nprocs</span><span class="o">.</span><span class="n">argtypes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">get_nprocs</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">__search_kdtree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">leafsize</span><span class="p">):</span>
    <span class="n">knn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ndata</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">numpy</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndata</span><span class="p">):</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">param</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">leafsize</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">_knn</span> <span class="o">=</span> <span class="n">search_kdtree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">K</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">knn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_knn</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">knn</span>

<span class="k">def</span> <span class="nf">__remote_process</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">qin</span><span class="p">,</span> <span class="n">qout</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">leafsize</span><span class="p">):</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c"># read input queue (block until data arrives)</span>
        <span class="n">nc</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">qin</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="c"># process data</span>
        <span class="n">knn</span> <span class="o">=</span> <span class="n">__search_kdtree</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">leafsize</span><span class="p">)</span>
        <span class="c"># write to output queue</span>
        <span class="n">qout</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span><span class="n">knn</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">knn_search</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">2048</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; find the K nearest neighbours for data points in data,</span>
<span class="sd">        using an O(n log n) kd-tree, exploiting all logical</span>
<span class="sd">        processors on the computer &quot;&quot;&quot;</span>

    <span class="n">ndata</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">param</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nproc</span> <span class="o">=</span> <span class="n">__num_processors</span><span class="p">()</span>
    <span class="c"># build kdtree</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">kdtree</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">leafsize</span><span class="o">=</span><span class="n">leafsize</span><span class="p">)</span>
    <span class="c"># compute chunk size</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">nproc</span><span class="p">)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">100</span> <span class="k">if</span> <span class="n">chunk_size</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="k">else</span> <span class="n">chunk_size</span>
    <span class="c"># set up a pool of processes</span>
    <span class="n">qin</span> <span class="o">=</span> <span class="n">processing</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="n">ndata</span><span class="o">/</span><span class="n">chunk_size</span><span class="p">)</span>
    <span class="n">qout</span> <span class="o">=</span> <span class="n">processing</span><span class="o">.</span><span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="n">ndata</span><span class="o">/</span><span class="n">chunk_size</span><span class="p">)</span>
    <span class="n">pool</span> <span class="o">=</span> <span class="p">[</span><span class="n">processing</span><span class="o">.</span><span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">__remote_process</span><span class="p">,</span>
                <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">rank</span><span class="p">,</span> <span class="n">qin</span><span class="p">,</span> <span class="n">qout</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">leafsize</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nproc</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="c"># put data chunks in input queue</span>
    <span class="n">cur</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span><span class="n">cur</span><span class="p">:</span><span class="n">cur</span><span class="o">+</span><span class="n">chunk_size</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">break</span>
        <span class="n">qin</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">nc</span><span class="p">,</span><span class="n">_data</span><span class="p">))</span>
        <span class="n">cur</span> <span class="o">+=</span> <span class="n">chunk_size</span>
        <span class="n">nc</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c"># read output queue</span>
    <span class="n">knn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">knn</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nc</span><span class="p">:</span>
        <span class="n">knn</span> <span class="o">+=</span> <span class="p">[</span><span class="n">qout</span><span class="o">.</span><span class="n">get</span><span class="p">()]</span>
    <span class="c"># avoid race condition</span>
    <span class="n">_knn</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">knn</span><span class="p">)]</span>
    <span class="n">knn</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tmp</span> <span class="ow">in</span> <span class="n">_knn</span><span class="p">:</span>
        <span class="n">knn</span> <span class="o">+=</span> <span class="n">tmp</span>
    <span class="c"># terminate workers</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pool</span><span class="p">:</span> <span class="n">p</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">knn</span>
</pre></div>
</div>
</div>
<div class="section" id="running-the-code">
<h1>Running the code<a class="headerlink" href="#running-the-code" title="Permalink to this headline">Â¶</a></h1>
<p>The following shows how to run the example code (including how input
data should be formatted):</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!python numbers=disable</span>

<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">clock</span>

<span class="k">def</span> <span class="nf">test</span><span class="p">():</span>
    <span class="n">K</span> <span class="o">=</span> <span class="mi">11</span>
    <span class="n">ndata</span> <span class="o">=</span> <span class="mi">10000</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">data</span> <span class="o">=</span>  <span class="mi">10</span> <span class="o">*</span> <span class="n">numpy</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">ndata</span><span class="o">*</span><span class="n">ndim</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">ndim</span><span class="p">,</span><span class="n">ndata</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">knn_search</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">leafsize</span><span class="o">=</span><span class="mi">2096</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
    <span class="n">test</span><span class="p">()</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">clock</span><span class="p">()</span>
    <span class="k">print</span> <span class="s">&quot;Elapsed time </span><span class="si">%.2f</span><span class="s"> seconds&quot;</span> <span class="o">%</span> <span class="n">t1</span><span class="o">-</span><span class="n">t0</span>

    <span class="c">#import profile          # using Python&#39;s profiler is not useful if you are</span>
    <span class="c">#profile.run(&#39;test()&#39;)   # running the parallel search.</span>
</pre></div>
</div>
<hr class="docutils" />
<p>CategoryCookbook</p>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Building a kd-tree</a></li>
<li><a class="reference internal" href="#searching-a-kd-tree">Searching a kd-tree</a></li>
<li><a class="reference internal" href="#quadratic-search-for-small-data-sets">Quadratic search for small data sets</a></li>
<li><a class="reference internal" href="#parallel-search-for-large-data-sets">Parallel search for large data sets</a></li>
<li><a class="reference internal" href="#running-the-code">Running the code</a></li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="Intersection.html"
                        title="previous chapter">Find the points at which two given functions intersect</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="KalmanFiltering.html"
                        title="next chapter">&lt;no title&gt;</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/KDTree.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="KalmanFiltering.html" title="&lt;no title&gt;"
             >next</a> |</li>
        <li class="right" >
          <a href="Intersection.html" title="Find the points at which two given functions intersect"
             >previous</a> |</li>
        <li><a href="index.html">CookBook 0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Matti Pastell.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>